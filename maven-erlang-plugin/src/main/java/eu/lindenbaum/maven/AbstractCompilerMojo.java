package eu.lindenbaum.maven;

import static eu.lindenbaum.maven.util.FileUtils.getFilesRecursive;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

import eu.lindenbaum.maven.util.ErlConstants;
import eu.lindenbaum.maven.util.ErlUtils;
import eu.lindenbaum.maven.util.FileUtils;
import eu.lindenbaum.maven.util.LoggingUtils;
import eu.lindenbaum.maven.util.ProcessListener;

import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.Mojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.logging.Log;
import org.apache.maven.project.MavenProject;

/**
 * Abstract base class for {@link Mojo}s compiling erlang code.
 * 
 * @author Tobias Schlager <tobias.schlager@lindenbaum.eu>
 * @author Olle Törnström <olle.toernstroem@lindenbaum.eu>
 */
abstract class AbstractCompilerMojo extends AbstractMojo {
  /**
   * Project to interact with.
   * 
   * @parameter expression="${project}"
   * @required
   * @readonly
   */
  protected MavenProject project;

  /**
   * If debugging information should be included.
   * 
   * @parameter default-value=false
   */
  private boolean debugInfo;

  /**
   * Additional compilation options.
   * 
   * @parameter
   */
  private String[] erlcOptions;

  /**
   * Include directory.
   * 
   * @parameter expression="${basedir}/src/main/include"
   */
  protected File includeDirectory;

  /**
   * Directories where dependencies are unpacked. This directory contains OTP applications (name-version
   * directories, with include and ebin sub directories).
   * 
   * @parameter expression="${project.build.directory}/lib/"
   * @required
   */
  private File libDirectory;

  /**
   * Directory with includes generated by earlier phases and where the mibs .hrl files are created.
   * 
   * @parameter expression="${project.build.directory}/include"
   */
  protected File outputIncludeDirectory;

  /**
   * Compile .erl source files (into .beam files).
   * 
   * @param inputDir path where .erl files reside
   * @param outputDir path to put .beam files into
   * @param include path where optional .hrl files reside
   * @param options optional compiler options
   * @return number of compiled files
   * @throws MojoExecutionException
   */
  protected final int compileSources(File inputDir, File outputDir, File include, String[] options) throws MojoExecutionException {
    Log log = getLog();
    List<File> sources = getFilesRecursive(inputDir, ErlConstants.ERL_SUFFIX);
    prepare(log, outputDir, sources, ErlConstants.ERL_SUFFIX, ErlConstants.BEAM_SUFFIX);

    int numSources = sources.size();
    if (numSources > 0) {
      log.info("Compiling " + numSources + " " + ErlConstants.ERL_SUFFIX + "-file"
               + (numSources > 1 ? "s" : "") + " into " + ErlConstants.BEAM_SUFFIX + " ("
               + outputDir.getAbsolutePath() + ")");
      List<String> command = getCommandLine(outputDir, include, options, false);
      AtomicBoolean failure = new AtomicBoolean(false);
      List<Runnable> jobList = new ArrayList<Runnable>();
      for (File source : sources) {
        jobList.add(getCompileJob(command, source, failure));
      }
      executeParallel(jobList, failure);
    }
    return numSources;
  }

  /**
   * Compile .mib source files (into .bin files).
   * 
   * @param inputDir path where .mib files reside
   * @param outputDir path to put .bin files into
   * @return number of compiled files
   * @throws MojoExecutionException
   */
  protected final int compileMibBin(File inputDir, File outputDir) throws MojoExecutionException {
    Log log = getLog();
    List<File> sources = getFilesRecursive(inputDir, ErlConstants.MIB_SUFFIX);
    prepare(log, outputDir, sources, ErlConstants.MIB_SUFFIX, ErlConstants.BIN_SUFFIX);

    int numSources = sources.size();
    if (numSources > 0) {
      log.info("Compiling " + numSources + " " + ErlConstants.MIB_SUFFIX + "-file"
               + (numSources > 1 ? "s" : "") + " into " + ErlConstants.BIN_SUFFIX + " ("
               + outputDir.getAbsolutePath() + ")");

      List<String> command = getCommandLine(outputDir, null, null, true);

      AtomicBoolean failure = new AtomicBoolean(false);
      List<Runnable> jobList = new ArrayList<Runnable>();
      for (File source : sources) {
        jobList.add(getCompileJob(command, source, failure));
      }
      executeParallel(jobList, failure);
    }
    return numSources;
  }

  /**
   * Compile .bin mib files (into .hrl files).
   * 
   * @param inputDir path where .bin files reside
   * @param outputDir path to put .hrl files into
   * @return number of compiled files
   * @throws MojoExecutionException
   */
  protected final int compileMibHrl(File inputDir, File outputDir) throws MojoExecutionException {
    Log log = getLog();
    List<File> sources = getFilesRecursive(inputDir, ErlConstants.BIN_SUFFIX);
    prepare(log, outputDir, sources, ErlConstants.BIN_SUFFIX, ErlConstants.HRL_SUFFIX);

    int numSources = sources.size();
    if (numSources > 0) {
      log.info("Compiling " + numSources + " " + ErlConstants.BIN_SUFFIX + "-file"
               + (numSources > 1 ? "s" : "") + " into " + ErlConstants.HRL_SUFFIX + " ("
               + outputDir.getAbsolutePath() + ")");

      List<String> command = getCommandLine(outputDir, null, null, true);

      AtomicBoolean failure = new AtomicBoolean(false);
      List<Runnable> jobList = new ArrayList<Runnable>();
      for (File source : sources) {
        jobList.add(getCompileJob(command, source, failure));
      }
      executeParallel(jobList, failure);
    }
    return numSources;
  }

  /**
   * Distributes the list of jobs onto the available number of processors.
   * 
   * @param jobList jobs to execute
   * @param failure indicating execution failures
   * @throws MojoExecutionException if execution failures were detected
   */
  protected static void executeParallel(List<Runnable> jobList, AtomicBoolean failure) throws MojoExecutionException {
    int maxConcurrentJobs = Runtime.getRuntime().availableProcessors();
    ExecutorService executor = Executors.newFixedThreadPool(maxConcurrentJobs);
    for (Runnable job : jobList) {
      executor.execute(job);
    }
    executor.shutdown();

    try {
      executor.awaitTermination(1200, TimeUnit.SECONDS);
    }
    catch (InterruptedException e) {
      throw new MojoExecutionException(e.getMessage(), e);
    }

    if (failure.get()) {
      throw new MojoExecutionException("failed to compile all resources");
    }
  }

  /**
   * Returns a compiler job for a specific command on the given source file.
   * 
   * @param command to execute
   * @param source to process
   * @param failure set to true in case of execution errors
   * @return the executable compile job
   */
  protected Runnable getCompileJob(List<String> command, final File source, final AtomicBoolean failure) {
    final Log log = getLog();
    final List<String> thisCommand = new ArrayList<String>(command);
    return new Runnable() {
      @Override
      public void run() {
        thisCommand.add(source.getAbsolutePath());
        try {
          ErlUtils.exec(thisCommand, log, null, new ProcessListener() {
            @Override
            public String processCompleted(int exitValue, List<String> processOutput) throws MojoExecutionException {
              for (String line : processOutput) {
                log.warn(line);
              }
              if (exitValue != 0) {
                throw new MojoExecutionException("Error compile module " + source + " -> " + exitValue);
              }
              return null;
            }
          });
        }
        catch (MojoExecutionException e) {
          failure.set(true);
        }
      }
    };
  }

  /**
   * Constructs the erlang command line to use for compilation.
   * 
   * @param outputDir output directory for artifacts
   * @param include optional additional include path (standard includes are {@link #includeDirectory} and
   *          {@link #outputIncludeDirectory})
   * @param options optional compiler options to be passed to the compiler
   * @param omitDebug omits the explicit debug options when enabled
   * @return the constructed command line array
   */
  protected List<String> getCommandLine(File outputDir, File include, String[] options, boolean omitDebug) {
    List<String> command = new ArrayList<String>();
    command.add(ErlConstants.ERLC);
    command.add("-I");
    command.add(this.includeDirectory.getPath());
    command.add("-I");
    command.add(this.outputIncludeDirectory.getPath());
    if (include != null) {
      command.add("-I");
      command.add(include.getPath());
    }
    for (File lib : FileUtils.getDependencies(this.libDirectory)) {
      command.add("-pa");
      command.add(lib.getAbsolutePath());
    }
    command.add("-o");
    command.add(outputDir.getPath());
    if (omitDebug) {
      command.add("+report_errors");
      command.add("+report_warnings");
      if (this.debugInfo) {
        command.add("+debug_info");
      }
    }
    if (this.erlcOptions != null) {
      command.addAll(Arrays.asList(this.erlcOptions));
    }
    if (options != null) {
      command.addAll(Arrays.asList(options));
    }
    return command;
  }

  /**
   * Prepares the given directory for a compilation process. If the directory does not exist it is created. If
   * there are artifacts of previous compilations (only for the sources to be compiled) these are removed.
   * 
   * @param log logger to use
   * @param directory to prepare
   * @param sources list of sources whose previous compilation are to be removed
   * @param sourceSuffix source file extensions in format e.g. {@code ".erl"}
   * @param destSuffix destination file extensions in format e.g. {@code ".beam"}
   */
  protected static void prepare(Log log,
                                File directory,
                                List<File> sources,
                                String sourceSuffix,
                                String destSuffix) {
    LoggingUtils.logDebug(log, "preparing output directory " + directory.getAbsolutePath());
    if (directory.exists()) {
      for (File source : sources) {
        File beam = new File(directory, source.getName().replace(sourceSuffix, destSuffix));
        if (beam.exists()) {
          LoggingUtils.logDebug(log, "deleting " + beam.getAbsolutePath());
          if (!beam.delete()) {
            LoggingUtils.logDebug(log, "failed to delete " + beam);
          }
        }
      }
    }
    else {
      directory.mkdir();
    }
  }
}
